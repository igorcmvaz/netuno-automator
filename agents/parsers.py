import csv
import logging
import re
from pathlib import Path
import time

from globals.constants import SIMULATION_OUTPUT_ATTRIBUTES
from globals.errors import CustomTimeoutError
from globals.types import ResultTuple, Variable

logger = logging.getLogger("triton")


def sleep_until_file_is_available(
        file_path: Path, tick: float = 0.01, timeout: float = 0.5) -> None:
    """
    Sleeps until the specified file no longer raises errors when opened, with a timeout.

    Args:
        file_path (Path): Path to the file to be checked.
        tick (float, optional): Time, in seconds, to wait between checks. Defaults to 0.01.
        timeout (float, optional): Timeout after which an exception is thrown, in seconds.
            Defaults to 0.5.
    """
    start_time = time.perf_counter()
    while True:
        if (time.perf_counter() - start_time) >= timeout:
            raise CustomTimeoutError(timeout)
        try:
            file = open(file_path)
        except (IOError, PermissionError):
            time.sleep(tick)
        else:
            file.close()
            break


class FileNameParser:

    @staticmethod
    def get_metadata(file_name: Path) -> tuple[str, str, str]:
        """
        Parses a file name to retrieve city name and climate model and scenario.

        The expected file name format is:
        `(optional_anything){city_name}_{model}_{scenario}.{extension}`

        NOTE: The underscore is used to separate fields, meaning it is expected to be
        present only at the limits between fields. The exception is the model name, which
        may contain underscores. In this case, the model name is parsed using up all extra
        underscores, which are replaced by hyphens for the final model name.

        Examples:
            * `(Netuno)Florianópolis_ACCESS-CM2_Histórico.csv`
            * `(Netuno)São Paulo_GFDL-CM4_SSP245.csv`
            * `(Netuno)Rio de Janeiro_MIROC6_SSP585.csv`
            * `Belo Horizonte_TaiESM1_Histórico.csv`
            * `Brasília_GFDL-CM4_SSP245.csv`
            * `Vitória_INM-CM4_8_SSP245.csv`

        Args:
            file_name (Path): Path to the file whose name should be parsed.

        Returns:
            tuple[str, str, str]: Tuple containing city name, climate model and scenario.
        """
        try:
            city, model, scenario = file_name.stem.split(".", 1)[0].split("_")
        except ValueError:
            logger.warning(
                f"File name '{file_name.name}' has different format than expected, "
                f"attempting to parse model containing '_' characters")
            city, *model, scenario = file_name.stem.split(".", 1)[0].split("_")
            model = "-".join(model)
            logger.info(f"Successfully parsed model '{model}' from file name")
        if (match := re.search(r"\(.*\)", city)):
            city = city.replace(match.group(), "")
        return city, model, scenario


class ResultParser:

    def __init__(self, results_file: Path):
        self.results_file = results_file

    def _float_from_string(self, value: str) -> float:
        """
        Converts a string value to a float, considering it might contain dots as thousands
        separators and commas as a decimal separator. If no commas are present, simple type
        casting is done.

        Args:
            value (str): Value to be converted.

        Returns:
            float: Float value obtained from the conversion.
        """
        if "," in value:
            value = value.replace(".", "").replace(",", ".")
        return float(value)

    def _get_results(self) -> list[dict[str, str | float]]:
        """
        Retrieves the simulation results from the CSV generated by Netuno 4.

        Returns:
            list[dict[str, str | float]]: List of dictionaries containing label and values
            for all results found in the file.
        """
        results = []
        sleep_until_file_is_available(self.results_file)
        with open(
                self.results_file,
                newline="",
                encoding=SIMULATION_OUTPUT_ATTRIBUTES["encoding"]) as csv_file:
            reader = csv.reader(
                csv_file, delimiter=SIMULATION_OUTPUT_ATTRIBUTES["delimiter"])
            results_section = False
            for row in reader:
                if SIMULATION_OUTPUT_ATTRIBUTES["start_of_results_label"] in row:
                    results_section = True
                    continue
                if results_section:
                    results.append({
                        "label": row[0],
                        "value": self._float_from_string(row[1])
                    })
        return results

    def parse_results(self) -> dict[str, Variable]:
        """
        Parses the results from `_get_results()` into a dictionary with matching Variables.

        Returns:
            dict[str, Variable]: Dictionary mapping metric names to their corresponding
            Variables.
        """
        logger.info(f"Parsing results from file '{self.results_file.name}'")
        results = self._get_results()
        return {
            "potential_savings": Variable(
                label=results[0]["label"], unit="%", value=results[0]["value"]),
            "average_rainwater_consumption": Variable(
                label=results[1]["label"], unit="liters/day", value=results[1]["value"]),
            "average_drinking_water_consumption": Variable(
                label=results[2]["label"], unit="liters/day", value=results[2]["value"]),
            "average_rainwater_overflow": Variable(
                label=results[3]["label"], unit="liters/day", value=results[3]["value"]),
            "period_when_demand_is_fully_met": Variable(
                label=results[4]["label"], unit="days", value=results[4]["value"]),
            "period_when_demand_is_partially_met": Variable(
                label=results[5]["label"], unit="%", value=results[5]["value"]),
            "period_when_demand_is_not_met": Variable(
                label=results[6]["label"], unit="%", value=results[6]["value"]),
        }

    def to_list(self, city: str, model: str, scenario: str,) -> list[ResultTuple]:
        """
        Converts the results from `parse_results()` into a list of tuples, each one
        containing a single metric and the corresponding city, model and scenario.

        Args:
            city (str): City corresponding to the results.
            model (str): Model corresponding to the results.
            scenario (str): Scenario corresponding to the results.

        Returns:
            list[ResultTuple]: List of tuples, each one with one metric and identified by
            name of the city, model and scenario.
        """
        content = []
        for metric, variable in self.parse_results().items():
            content.append((
                city,
                model,
                scenario,
                metric,
                variable.label,
                variable.value,
                variable.unit))
        return content
